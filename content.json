{"meta":{"title":"Yoler的小站","subtitle":"你说向前看 毕竟将来重要","description":null,"author":"Yoler|雷永亮","url":"http://yoursite.com"},"pages":[{"title":"gallery","date":"2017-06-06T08:19:05.000Z","updated":"2017-06-06T09:30:22.000Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-06-06T08:19:05.000Z","updated":"2017-06-06T09:59:00.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"WHAT I AMI AM YOLER一个毕业于建筑高校从事前端开发的摄影爱好者"},{"title":"links","date":"2017-06-06T08:19:05.000Z","updated":"2017-06-06T09:27:42.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"小鱼儿: http://ysir.me"}],"posts":[{"title":"文件下载","slug":"File-DownLoad","date":"2017-05-22T01:52:34.000Z","updated":"2017-06-09T09:51:17.000Z","comments":true,"path":"2017/05/22/File-DownLoad/","link":"","permalink":"http://yoursite.com/2017/05/22/File-DownLoad/","excerpt":"","text":"&lt;button onclick=\"download('11.txt', 'fsdfdsfsdfsdfsdfsdfsf')\">下载&lt;/button> function download(filename, content) { var aLink = document.createElement('a') var blob = new Blob([content]) var event = new MouseEvent('click', { 'view': window, 'bubbles': true, //是否冒泡 'cancelable': true //事件是否可以取消 }); aLink.download = filename aLink.href = URL.createObjectURL(blob) aLink.dispatchEvent(event) }","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"vue-webpack配置文件","slug":"vue-webpack配置文件","date":"2017-03-20T01:24:49.000Z","updated":"2017-06-09T09:58:28.000Z","comments":true,"path":"2017/03/20/vue-webpack配置文件/","link":"","permalink":"http://yoursite.com/2017/03/20/vue-webpack配置文件/","excerpt":"","text":"今天来总结一下自己搭建vue开发环境的一些心得，其实最重要的就是webpack的配置，下面直接贴出配置代码： var path = require(\"path\"); module.exports = { entry: { app: path.resolve(__dirname, \"./main.js\") // entry:顾名思义入口文件,app/main.js,输入名字为 app.js }, output: { path: path.resolve(__dirname, \"./build\"),//输出路径 publicPath: 'build/', //调试或者 CDN 之类的域名,稍候会用到 filename: \"[name].js\" //配置生成的文件名 }, resolve: { // require时省略的扩展名，如：require('module') 不需要module.js extensions: ['', '.js', '.vue'], }, module: { loaders: [ { test: /\\.vue$/, loader: 'vue' }, { test: /\\.css?$/, loader: 'file' }, { test: /\\.js$/, loader: 'babel', exclude: /node_modules/ }, { test: /\\.(png|js?eg|gif|svg|woff2?|eot|ttf)(\\?.*)?$/, loader: 'url', } ]//模块加载器，默认null }, babel: { presets: ['es2015'], plugins: ['transform-runtime'] }, plugins: [] //插件，默认null }; 以及package.json文件： { \"name\": \"h5app\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"author\": \"yoler\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.22.1\", \"babel-loader\": \"^6.2.10\", \"babel-plugin-istanbul\": \"^3.1.2\", \"babel-plugin-transform-runtime\": \"^6.22.0\", \"babel-preset-es2015\": \"^6.22.0\", \"babel-preset-stage-2\": \"^6.22.0\", \"babel-register\": \"^6.22.0\", \"css-loader\": \"^0.26.4\", \"element-ui\": \"^1.2.4\", \"file-loader\": \"^0.10.1\", \"url-loader\": \"^0.5.8\", \"vue\": \"^2.2.2\", \"vue-loader\": \"^11.1.4\", \"vue-resource\": \"^1.2.1\", \"vue-router\": \"^2.3.0\", \"vue-style-loader\": \"^2.0.0\", \"vue-template-compiler\": \"^2.2.2\", \"vuex\": \"^2.2.1\" } }","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"模拟滚动条","slug":"模拟滚动条","date":"2017-02-28T09:49:19.000Z","updated":"2017-06-09T10:00:34.000Z","comments":true,"path":"2017/02/28/模拟滚动条/","link":"","permalink":"http://yoursite.com/2017/02/28/模拟滚动条/","excerpt":"","text":"最近由于需求原因，用vue做开发，自己动手模拟原生滚动条,做过之后觉得也没有那么难点击观看Demo 下面直接贴出部分核心代码 initscrollbar () { if (this.$refs.scroll_box.offsetHeight - this.$refs.page_content.offsetHeight &lt;= 0) { this.rate = this.$refs.scroll_box.offsetHeight / this.$refs.page_content.offsetHeight this.scroll_bar_height = this.rate * this.$refs.scroll_box.offsetHeight - 4 + 'px' this.scroll_bar_top = -this.speed * this.rate + 2 + 'px' if (this.$refs.scroll_box.offsetHeight - this.$refs.page_content.offsetHeight >= this.speed) { this.speed = this.$refs.scroll_box.offsetHeight - this.$refs.page_content.offsetHeight this.page_content_top = this.speed + 'px' this.scroll_bar_top = -this.speed * this.rate + 2 + 'px' } } else { this.speed = 0 this.page_content_top = this.speed + 'px' this.scroll_bar_height = 0 } } 这一段代码是初始化滚动条的高度和位置，当窗口大小发生改变的时候通过容器高度和内容高度来计算出新的比率rate，再通过这个rate初始化滚动条的高度 this.scroll_bar_height = this.rate * this.$refs.scroll_box.offsetHeight - 4 + 'px' scroll_bar_down (event) { this.disy = event.clientY document.addEventListener('mousemove', this.scroll_bar_move) document.addEventListener('mouseup', this.scroll_bar_up) this.curspeed = this.speed * this.rate this.mousestate = 1 }, scroll_bar_move (event) { document.body.style.cursor = 'default' let y = this.disy - event.clientY this.speed = (this.curspeed + y) / this.rate if (this.speed >= 0) { this.speed = 0 } if (this.$refs.scroll_box.offsetHeight - this.$refs.page_content.offsetHeight >= this.speed) { this.speed = this.$refs.scroll_box.offsetHeight - this.$refs.page_content.offsetHeight } this.page_content_top = this.speed + 'px' this.scroll_bar_top = -this.speed * this.rate + 2 + 'px' }, scroll_bar_up () { document.removeEventListener('mousemove', this.scroll_bar_move) this.mousestate = 0 } 这一段代码是滚动条响应鼠标拖拽事件，当鼠标按下的时候记录此时的Y坐标，然后移动鼠标，计算移动距离。注意： 滚动条移动的距离和鼠标移动的距离相等，而内容移动的距离要除以对应的比率，也就是rate scroll (event) { if (this.$refs.scroll_box.offsetHeight - this.$refs.page_content.offsetHeight &lt;= 0) { if (event.wheelDelta === 120) { this.speed += 50 if (this.speed >= 0) { this.speed = 0 } this.page_content_top = this.speed + 'px' this.scroll_bar_top = -this.speed * this.rate + 2 + 'px' } else if (event.wheelDelta === -120) { this.speed -= 50 if (this.$refs.scroll_box.offsetHeight - this.$refs.page_content.offsetHeight >= this.speed) { this.speed = this.$refs.scroll_box.offsetHeight - this.$refs.page_content.offsetHeight } this.page_content_top = this.speed + 'px' this.scroll_bar_top = -this.speed * this.rate + 2 + 'px' } } } 这段代码是滚动条响应鼠标滚动事件，当鼠标滚轮滚动一下，对应滚动条的移动距离，可自行设定。 下面贴出Html代码，仅供参考 &lt;div class=\"scroll_box\" ref=\"scroll_box\"> &lt;div class=\"page_content\" :style=\"{top: page_content_top}\" ref=\"page_content\"> &lt;div class=\"page_item\" v-for=\"(value, index) in pages\"> &lt;div class=\"page_wrap\" @click=\"page_seledt(index)\" :class=\"{border: value.state}\"> &lt;div class=\"page_thumbnail\">&lt;/div> &lt;div class=\"page_name\"> &lt;span>{{index}}&lt;/span> &lt;input type=\"text\" v-model=\"value.name\"> &lt;/div> &lt;div class=\"page_tool\" v-show=\"value.state\"> &lt;div class=\"page_del\">&lt;/div> &lt;div class=\"page_liked\">&lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;div class=\"warp_scroll_bar\" v-show=\"scroll_bar_state\" ref=\"scroll_bar\"> &lt;div class=\"scroll_bar\" :style=\"{top: scroll_bar_top,height: scroll_bar_height}\" :class=\"{ready: mousestate}\">&lt;/div> &lt;/div> &lt;/div> 如果大家有什么意见或建议，请在下方评论区留言","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"如何提升阅读效率","slug":"如何提升阅读效率","date":"2017-02-22T02:57:03.000Z","updated":"2017-02-22T03:18:12.000Z","comments":true,"path":"2017/02/22/如何提升阅读效率/","link":"","permalink":"http://yoursite.com/2017/02/22/如何提升阅读效率/","excerpt":"","text":"提升阅读效率是一个系统工程，不可一蹴而就，要想做到，你至少要在四个方面下功夫： 1.体力：体力是精力的保证，高强度的阅读需要强大的精力来支撑；2.意愿：为什么读？什么是自己能保持高强度阅读的精神支撑？3.知识：有很多比较难的书，要求阅读者必须要有一定的知识基础或者对应学科的知识基础，举个例子，如果你从来没有学过物理和高等数学或者相关基础特别差，却一下子想要高强度高质量地吸收理论力学，泛函分析相关的知识，可能吗？别说书里面的内容了，目录你都看不懂。4.逻辑：其实，很多书里面的论证和说明，都是统一的论证模式，比如因果链，比如演绎归纳结合，比如反证，如果你能快速地找出隐含的论证模式，很多时候是可以跳过大段文本直接看结论的。但是：提升阅读的逻辑敏锐度，是在以上123点都做到的前提之下的——阅读时候的逻辑分析能力，是一个因为长期阅读自然而然培养出来的能力，或者说结果。 有的人提到的什么目录法，笔记法，乃至其他的画图法，联想法，默读法，各种花样层出的方法，都不过是术而已，真要达到高效阅读，必须要重道，道之后，才是术。所有好的学习与阅读方法，最主要的部分不是提升你的学习效率，而是改变你的心智，让你因为这个方法，爱上学习和阅读，在此基础上，再是效率的提升。方法是次要的——方法（术）和成功没绝对的相关关系，精力，兴趣，基础（道）才有。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"写在年末","slug":"写在年末","date":"2017-01-20T09:08:16.000Z","updated":"2017-01-20T10:19:19.377Z","comments":true,"path":"2017/01/20/写在年末/","link":"","permalink":"http://yoursite.com/2017/01/20/写在年末/","excerpt":"","text":"时光飞逝 当我提笔时已是快要离开的时候了离下班还有12分钟 看了一眼窗外黄昏的夕阳在天边留下一片红晕的晚霞远处的高楼大厦泛着金黄的光惬意 安详 我很感谢我能来到亿图一家不是很大的公司我清楚的记得当我刚去的时候连一个表单页面都写的很艰难不知道什么是API什么是AJAX……所以我就默默的努力其他人六点多就走了我熬到七点老板说走吧明天再来做 在这里我感到很自由没有迟到没有强制加班更多的是自我约束还有好多好多随便吃的零食还有一群可爱友好的小伙伴 有时候遇到难题也会困扰好久思考着 思考着 天就黑了又一天就结束了google还显示着翻阅的资料github又多了一个版本记录 这一年我有成长但是不够努力 还有好多坏习惯没改正其中拖延症是最严重的 呵呵上学时将自己的签名写为雷厉风行 永不言弃 亮丽一生 现在真是惭愧啊","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"flex布局总结","slug":"flex布局总结","date":"2017-01-17T06:47:19.000Z","updated":"2017-06-09T09:57:56.000Z","comments":true,"path":"2017/01/17/flex布局总结/","link":"","permalink":"http://yoursite.com/2017/01/17/flex布局总结/","excerpt":"","text":"Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 .box{ display: flex; } 行内元素也可以使用Flex布局。 .box{ display: inline-flex; } 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器有如下6个属性：1.flex-direction：属性决定主轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse; } 有如下四个值: row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2.flex-wrap: 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可能取三个值: nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 3.flex-flow: 该属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: &lt;flex-direction> || &lt;flex-wrap>; } 4.justify-content: 该属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右: flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5.align-items: 该属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下: flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6.align-content: 该属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 该属性可能取6个值: flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性,以下6个属性设置在项目上:1.order: 定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: &lt;integer>; } 2.flex-grow: 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: &lt;number>; /* default 0 */ } 3.flex-shrink: 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: &lt;number>; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4.flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: &lt;length> | auto; /* default auto */ } 5.flex: 该属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;'flex-grow'> &lt;'flex-shrink'>? || &lt;'flex-basis'> ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 6.align-self: 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"初笔","slug":"初笔","date":"2017-01-16T05:42:38.000Z","updated":"2017-01-16T10:23:28.000Z","comments":true,"path":"2017/01/16/初笔/","link":"","permalink":"http://yoursite.com/2017/01/16/初笔/","excerpt":"","text":"以前 总想有一个属于自己的网站用自己的名字来命名 写一些个人简介写一写生活杂谈 终于今天搭建了自己的专属博客以后生活的点点滴滴都将呈现在这里 或许写着 写着我就会变成一个作家这也是不错的 以前从没有写过学习笔记不爱写也没有地方写csdn的博客太丑作为一个前端开发工程师对美观的要求是极致的这个主题还暂算满意 成长的过程中需要不断的积累人说好记性 不如烂笔头此刻我是绚烂的","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}